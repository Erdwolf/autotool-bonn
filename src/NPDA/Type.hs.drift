-- -*- mode: haskell -*-

module Autolib.NPDA.Type

-- nicht-deterministischer Kellerautomat
--   $Id$

( module Autolib.NPDA.Type
, module Autolib.Set
, module Autolib.FiniteMap
)

where


import Autolib.Set
import Autolib..FiniteMap
import Autolib.Schichten
import Autolib.Size

import Autolib.ToDoc
import Autolib.Reader

import Data.Maybe
import Autolib.Reporter

class ( Reader z , Reader [z], ToDoc z, ToDoc [z], Ord z )
    => RTO z
instance ( Reader z , Reader [z], ToDoc z, ToDoc [z], Ord z )
    => RTO z

      
data RTO z => Modus z = Leerer_Keller | Zustand (Set z) 

{-! for Modus derive: Reader, ToDoc !-}

class ( RTO x, RTO y, RTO z ) 
    => NPDAC x y z
instance ( RTO x, RTO y, RTO z ) 
    => NPDAC x y z

data NPDAC x y z => NPDA x y z = 
     NPDA { eingabealphabet  :: Set x 
	  , kelleralphabet   :: Set y 
	  , zustandsmenge    :: Set z 
	  , startzustand     :: z
	  , startsymbol	     :: y
	  , akzeptiert	     :: Modus z
	  , transitionen     :: FiniteMap (Maybe x, z, y) (Set (z, [y]))
	  }

{-! for NPDA derive: Reader, ToDoc !-}

instance NPDAC x y z => Size (NPDA x y z) where
    size a = length $ unCollect' $ tafel a

------------------------------------------------------------------------

-- | specialized instances used for finite automata (testing)
instance  ( NPDAC x y z )
      => ToDoc (FiniteMap (Maybe x, z, y) (Set (z, [y])) where
    toDocPrec p fm = docParen (p >= fcp)
                   $ text "collect" <+> toDocPrec fcp (unCollect' fm)

instance  ( NPDAC x y z )
        => Reader (FiniteMap (Maybe x, z, y) (Set (z, [y])) where
    reader = default_reader <|> do
        my_reserved "collect"
        xys <- reader
        return $ collect' xys

-- | collect transition function from list of quintuples
collect' :: ( NPDAC x y z )
        => [ (Maybe x, z, y, z, [y]) ] 
	-> FiniteMap (Maybe x, z, y) (Set (z, [y])) 
collect' pxqs = addListToFM_C union emptyFM $ do
    ( mx, z, y, z', ys ) <- pxqs
    return ( (mx, z, y), unitSet (z', ys) )

-- | represent transition function as list of quintuples
unCollect' :: NPDAC x y z
	   => FiniteMap (Maybe x, z, y) (Set (z, [y])) 
	   -> [ (Maybe x, z, y, z, [y]) ] 
unCollect fm = do
    ( (mx, z, y), qs ) <- fmToList fm
    ( z', ys ) <- setToList qs
    return ( mx, z, y, z', ys )

------------------------------------------------------------------------

-- | mit absturzgefahr
the :: Maybe a -> a
the = fromMaybe ( error "the" )








