{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "NPDA/Type.hs.drift" #-}
-- -*- mode: haskell -*-

module NPDA.Type

-- nicht-deterministischer Kellerautomat
-- $Id$

( module NPDA.Type
, module Sets
, module FiniteMap
)

where


import Sets
import FiniteMap
import Schichten
import Size

import ToDoc
import Reader

import ReadFM
import Maybe
import Reporter

class ( Reader z , Reader [z], ToDoc z, ToDoc [z], Ord z )
    => RTO z
instance ( Reader z , Reader [z], ToDoc z, ToDoc [z], Ord z )
    => RTO z

      
data RTO z => Modus z = Leerer_Keller | Zustand (Set z) 

{-! for Modus derive: Reader, ToDoc !-}

instance RTO z => Read (Modus z) where
    readsPrec = parsec_readsPrec
instance RTO z => Show (Modus z) where
     show = render . toDoc

class ( RTO x, RTO y, RTO z ) 
    => NPDAC x y z
instance ( RTO x, RTO y, RTO z ) 
    => NPDAC x y z

data NPDAC x y z => NPDA x y z = 
     NPDA { eingabealphabet  :: Set x 
	  , kelleralphabet   :: Set y 
	  , zustandsmenge    :: Set z 
	  , startzustand     :: z
	  , startsymbol	     :: y
	  , akzeptiert	     :: Modus z
	  , tafel	     :: FiniteMap (Maybe x, z, y) (Set (z, [y]))
	  }

{-! for NPDA derive: Reader, ToDoc !-}

instance NPDAC x y z => Read (NPDA x y z) where
    readsPrec = parsec_readsPrec
instance NPDAC x y z => Show (NPDA x y z) where
     show = render . toDoc


-- helpers für weniger klammern in der eingabe

collect :: NPDAC x y z
	=> [ ((Maybe x, z, y), (z, [y])) ]
	-> FiniteMap (Maybe x, z, y) (Set (z, [y]))
collect pairs = addListToFM_C union emptyFM $ do
    ( x, y ) <- pairs ; return ( x, unitSet y )

unCollect :: FiniteMap (Maybe x, z, y) (Set (z, [y]))
	  ->  [ ((Maybe x, z, y), (z, [y])) ]
unCollect fm = do
    ( x, ys ) <- fmToList fm
    y <- setToList ys
    return (x, y)


instance NPDAC x y z => Size (NPDA x y z) where
    size a = sum $ do
	 ( x, ys ) <- fmToList $ tafel a
	 y <- setToList ys
	 return 1

------------------------------------------------------------------------

lookupset :: Ord a => FiniteMap a (Set b) -> a -> Set b
lookupset fm x = case lookupFM fm x of
    Just m -> m; Nothing -> emptySet

the :: Maybe a -> a
-- mit absturzgefahr
the = fromMaybe ( error "the" )








{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance (NPDAC x y z,Reader x,Reader y,
	  Reader z) => Reader (NPDA x y z) where
    readerPrec d = readerParen (d > 9)
	       ((do my_reserved "NPDA"
		    my_braces ((do my_reserved "eingabealphabet"
				   my_equals
				   aa <- readerPrec 0
				   my_comma
				   my_reserved "kelleralphabet"
				   my_equals
				   ab <- readerPrec 0
				   my_comma
				   my_reserved "zustandsmenge"
				   my_equals
				   ac <- readerPrec 0
				   my_comma
				   my_reserved "startzustand"
				   my_equals
				   ad <- readerPrec 0
				   my_comma
				   my_reserved "startsymbol"
				   my_equals
				   ae <- readerPrec 0
				   my_comma
				   my_reserved "akzeptiert"
				   my_equals
				   af <- readerPrec 0
				   my_comma
				   my_reserved "tafel"
				   my_equals
				   ag <- readerPrec 0
				   return (NPDA aa ab ac ad ae af ag)))))

instance (NPDAC x y z,ToDoc x,ToDoc y,
	  ToDoc z) => ToDoc (NPDA x y z) where
    toDocPrec d (NPDA aa ab ac ad ae af ag) = docParen (d >= 10)
	      (text "NPDA" <+> dutch_record
	       [text "eingabealphabet" <+> equals <+> toDocPrec 0 aa,
		text "kelleralphabet" <+> equals <+> toDocPrec 0 ab,
		text "zustandsmenge" <+> equals <+> toDocPrec 0 ac,
		text "startzustand" <+> equals <+> toDocPrec 0 ad,
		text "startsymbol" <+> equals <+> toDocPrec 0 ae,
		text "akzeptiert" <+> equals <+> toDocPrec 0 af,
		text "tafel" <+> equals <+> toDocPrec 0 ag])

instance (RTO z,Reader z) => Reader (Modus z) where
    readerPrec d = readerParen (d > 9)
	       ((do my_reserved "Leerer_Keller"
		    return (Leerer_Keller))
		<|>
		(do my_reserved "Zustand"
		    aa <- readerPrec 0
		    return (Zustand aa)))

instance (RTO z,ToDoc z) => ToDoc (Modus z) where
    toDocPrec d (Leerer_Keller) = text "Leerer_Keller"
    toDocPrec d (Zustand aa) = docParen (d >= 10)
	      (text "Zustand" <+> fsep [toDocPrec 10 aa])

--  Imported from other files :-
