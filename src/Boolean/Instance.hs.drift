-- -*- mode: haskell -*-

module Boolean.Instance where

--  $Id$

import Boolean.Op
import qualified Autolib.TES.Binu as B
import qualified Boolean.Equiv

import Challenger.Partial
import qualified Autolib.Reporter.Set

import Data.Typeable
import Text.XML.HaXml.Haskell2Xml

import Autolib.ToDoc
import Autolib.Reader
import Autolib.Reporter
import Autolib.Set

import Inter.Types

data Boolean = Boolean deriving ( Eq, Ord, Typeable )

{-! for Boolean derive: Haskell2Xml, ToDoc, Reader !-}

data BI =
     BI { formula :: Exp Bool
	, operators :: Set ( Op Bool )
	}
     deriving ( Typeable )

{-! for BI derive: Haskell2Xml, ToDoc, Reader !-}

data BIC =
     BIC { formula_size :: Int
	 , operators_in_instance :: B.Binu ( Op Bool )
	 , operators_in_solution :: Set ( Op Bool )
	 }
     deriving ( Typeable )

{-! for BIC derive: Haskell2Xml, ToDoc, Reader !-}

instance Partial Boolean BI ( Exp Bool ) where

    describe p i = vcat
        [ text "Gesucht ist ein aussagenlogischer Ausdruck,"
	, text "der äquivalent ist zu:"
	, nest 4 $ toDoc $ formula i
	, text ""
	, parens $ vcat [ text "die Baumstruktur dieses Ausdrucks ist:"
			, nest 4 $ draw  $ formula i
			]
	, text "und nur diese Operatoren enthält:"
	, nest 4 $ toDoc $ operators i
	]

    initial p i = formula i

    partial p i b = do
        inform $ vcat
	       [ text "Die Baumstruktur Ihrer Einsendung ist:"
	       , nest 4 $ draw b
	       , text ""
	       ]
        Autolib.Reporter.Set.subeq
	    ( parens $ text "benutzte Operatoren" , syms b )
	    ( parens $ text "erlaubte Operatoren" , operators i )
	Autolib.Reporter.Set.subeq
	    ( parens $ text "benutzte Variablen" , vars b )
	    ( parens $ text "Variablen der Aufgabenstellung",vars $ formula i )

    total p i b = do
        Boolean.Equiv.check ( formula i ) b



make :: Make
make = direct Boolean $  BI 
       { formula = read "x == (y == z)"
       , operators = read "mkSet [ false, true, !, ||, && ]"
       }



