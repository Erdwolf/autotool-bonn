-- -*- mode: haskell -*-

module Pump.Type where

-- -- $Id$

import ToDoc
import Reader

import Reporter

import Size
import Data.FiniteMap


--------------------------------------------------------------------------

class ( Ord z,  Show z, ToDoc z, ToDoc [z], Reader z ) => Pumping z where
    tag :: z -> String
    tag_show :: z -> String
    admissable :: Int -> z -> Reporter ()
    inflate_show :: Int -> z -> String
    inflate_show_i :: z -> String

    inflate :: Int -> z -> String
    zerlegungen :: String -> Int -> [ z ]

    exempel :: z

--------------------------------------------------------------------------

data Pumping z => 
     Pump z = Nein
	     { wort :: FiniteMap Int String }
	    | Ja
	     { n :: Int
	     , zerlege :: FiniteMap String z
	     }

{-! for Pump derive: Reader, ToDoc !-}     


instance Pumping z => Show ( Pump z ) where 
    show = render . toDoc
instance Pumping z => Read ( Pump z ) where
    readsPrec = parsec_readsPrec


instance Pumping z => Size ( Pump z ) where
    size p @ Nein {} = sum [ length $ w | (n,w) <- fmToList $ wort p ]
    size p @ Ja   {} = n p


