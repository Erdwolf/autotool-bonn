{-# OPTIONS -fglasgow-exts -fallow-overlapping-instances -fallow-incoherent-instances  #-}

module PL.Struktur where

import PL.Signatur
import PL.Util

import Autolib.TES.Identifier
import Autolib.FiniteMap
import Autolib.Size
import Autolib.Set
import Autolib.Reader
import Autolib.ToDoc
import Autolib.Reporter
import Data.Typeable

data Predicate u = Predicate { unPredicate :: Set [u] }
     deriving ( Eq, Ord, Typeable )

instance Size ( Predicate u ) where
    size ( Predicate s ) = cardinality s

instance ToDoc u => ToDoc ( Predicate u ) where
    toDoc ( Predicate ts ) = as_set ts

as_set ts = braces $ Autolib.ToDoc.sepBy comma $ do
        t <- setToList $ ts
	return $ parens $ Autolib.ToDoc.sepBy comma $ map toDoc t

instance ( Ord u, Reader u ) => Reader ( Predicate u ) where
    reader = fmap Predicate from_set

data Function  u = Function { unFunction :: FiniteMap [u] u }
     deriving ( Eq, Ord, Typeable )

instance Size ( Function u ) where
    size ( Function f ) = sizeFM f

instance ( Ord u, ToDoc u ) => ToDoc ( Function u ) where
    toDoc ( Function fm ) = as_set $ mkSet $ do
        ( xs, y ) <- fmToList fm
	return $ xs ++ [y]

instance ( Ord u, Reader u ) => Reader ( Function u ) where
    reader = do
       tuples <- from_set
       return $ Function $ listToFM $ do
           tu <- setToList $ tuples
	   return ( init tu, last tu )

from_set :: ( Ord u, Reader u ) => Parser ( Set [u] )
from_set = fmap mkSet
	 $ my_braces $ ( `Autolib.Reader.sepBy` my_comma ) 
	 $ my_parens $ ( `Autolib.Reader.sepBy` my_comma ) 
	 $ reader

data Ord u => Struktur u = 
     Struktur { universum  :: Set u
	      , predicates :: FiniteMap Identifier ( Predicate u ) 
	      , functions  :: FiniteMap Identifier ( Function  u )
	      }
     deriving ( Eq, Ord, Typeable )

instance Ord u => Size ( Struktur u ) where
    size s = cardinality ( universum s )
	   + sum ( do ( r, rr ) <- fmToList $ predicates s ; return $ size rr )
	   + sum ( do ( f, ff ) <- fmToList $ functions  s ; return $ size ff )

-- | wir testen, ob alle Symbole der Signatur
-- wirklich in der Struktur vorkommen.
-- es ist erlaubt, daÃ zusÃ¤tzlichen Symbole vorkommen.
instance ( ToDoc u, Ord u ) => Signed ( Struktur u ) where
     check sig s = do
	  checkit "Funktion" 
		  ( keysFM . unFunction ) ( funktionen sig ) ( functions s )
	  checkit "Relation" 
		  ( setToList . unPredicate ) ( relationen sig ) ( predicates s )

checkit tag get_args arities values = sequence_ $ do
    ( f, arity ) <- fmToList $ arities
    return $ do
        this <- find_or_complain tag values f
        sequence_ $ do
            arg <- get_args this
            return $ do
                when ( length arg /= arity ) $ reject $ vcat
                     [ text "Interpretation fÃ¼r" <+> text tag <> text "ssymbol" 
		             <+> toDoc f
                     , text "Falsche Stelligkeit fÃ¼r" <+> toDoc arg
                     ]
	      
empty :: Ord u
      => Signatur 
      -> Set u 
      -> Struktur u
empty sig uni = 
    Struktur { universum = uni
	     , predicates = listToFM $ do
	           ( p, a ) <- fmToList $ relationen sig
		   return ( p, Predicate emptySet )
	     , functions = listToFM $ do
	           ( f, a ) <- fmToList $ funktionen sig
		   return ( f, Function emptyFM )
	     }

	    
{-! for Struktur derive: Reader, ToDoc !-}

-- local variables:
-- mode: haskell
-- end

