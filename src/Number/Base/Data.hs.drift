-- -*- mode: haskell -*-

module Number.Base.Data where

import Autolib.ToDoc
import Autolib.Reader
import Data.Typeable
import Text.XML.HaXml.Haskell2Xml

import Data.Char

data Ziffer = Ziffer Int
    deriving ( Eq, Ord, Typeable )

{-! for Ziffer derive: Haskell2Xml !-}

zehn :: Int
zehn = 10

instance ToDoc Ziffer where
    toDoc (Ziffer z) =
        if (0 <= z) && (z < zehn) then toDoc z
        else if z - zehn <= fromEnum 'Z' - fromEnum 'A' 
             then Autolib.ToDoc.char $ toEnum $ fromEnum 'A' + (z - zehn)
             else error $ "cannot convert digit to character: " ++ show z

instance Reader Ziffer where
    reader = 
            do d <- satisfy isDigit
               my_whiteSpace
               return $ Ziffer $ fromEnum d - fromEnum '0'
        <|> do d <- satisfy isLower
               my_whiteSpace
               return $ Ziffer $ fromEnum d - fromEnum 'a' + zehn
        <|> do d <- satisfy isUpper
               my_whiteSpace
               return $ Ziffer $ fromEnum d - fromEnum 'A' + zehn
     

data Zahl = Zahl { basis :: Int
                 , ziffern :: [ Ziffer ]
                 }
    deriving ( Eq, Ord, Typeable )

{-! for Zahl derive: Reader, ToDoc, Haskell2Xml !-}

-------------------------------------------------------------------

class Num b => Wert a b where 
    wert :: a -> b

class Num b => Wert_at a b where 
    wert_at :: Int -> a -> b

instance Wert_at [ Ziffer ] Integer where
    wert_at b zs = 
        foldl ( \ x (Ziffer y) -> fromIntegral b * x + fromIntegral y ) 0 zs

instance Wert Zahl Integer where
  wert z = wert_at (basis z) (ziffern z)
