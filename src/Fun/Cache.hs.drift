-- -*- mode: haskell -*-

module Fun.Cache 

-- $Id$

( Cache -- abstrakt
, empty
, lookup
, insert
)

where

import Prelude hiding ( lookup )

import FiniteMap
import ReadFM

import ToDoc hiding ( empty )
import Reader

data Ord k => Cache k e = Cache ( FiniteMap k e )

{-! for Cache derive : Reader, ToDoc !-}

instance (Ord k, ToDoc k, ToDoc e) => Show (Cache k e) where
    show = render . toDoc

instance (Ord k, Reader k, Reader e) => Read (Cache k e) where
    readsPrec = parsec_readsPrec


empty :: Ord k => Cache k e
empty = Cache emptyFM

lookup :: Ord k => Cache k e -> k -> Maybe e
lookup (Cache c) k = lookupFM c k

insert :: Ord k => Cache k e -> k -> e -> Cache k e
insert (Cache c) k e = Cache (addToFM c k e)

