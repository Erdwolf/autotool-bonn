{-# OPTIONS -fglasgow-exts -fno-monomorphism-restriction #-}

module Fun.Direct.Config where

import Fun.Type

import Autolib.Reader
import Autolib.ToDoc
import Autolib.Reporter
import Data.Typeable

data Primrec_2D = Primrec_2D deriving ( Typeable )

{-! for Primrec_2D derive: Reader, ToDoc !-}

data Config = 
     Config { table :: Matrix Integer
	    , properties :: [ Property ]
	    }

{-! for Config derive: Reader, ToDoc !-}

data ( Reader a, ToDoc a ) => Matrix a =
     Matrix { width :: Int
	    , height :: Int
	    , contents :: [[a]]
	    }

{-! for Matrix derive: Reader !-}

mktafel2 :: Matrix Integer -> Reporter Tafel2 
mktafel2 m = do
    when ( length ( contents m ) /= height m ) $ reject
	 $ text "Der Inhalt der Matrix hat nicht die HÃ¶he" 
         <+> toDoc ( height m )
    sequence $ do
        ( k, xs) <- zip [0..] $ contents m
        return $ when ( length xs /= width m ) $ reject
	     $ text "Die Zeile" <+> toDoc k 
	     <+> text "hat nicht die Breite" <+> toDoc ( width m )
    return $ Tafel2 $ listArray ((0,0), (height m - 1, width m - 1 ))
		    $ concat $ contents m

instance ( Reader a, ToDoc a ) => ToDoc ( Matrix a ) where
    toDocPrec d m = docParen ( d >= 10 ) $
        text "Matrix" </> dutch_record
	    [ text "width" <+> equals <+> toDocPrec 0 ( width m )
	    , text "height" <+> equals <+> toDocPrec 0 ( height m )
	    , text "contents" <+> equals 
	        <+> dutch_matrix ( map ( map toDoc ) $ contents m ) 
	    ]

dutch_matrix = dutch_vertical_list . map dutch_horizontal_list
dutch_vertical_list = dutch_combined_list vcat
dutch_horizontal_list = dutch_combined_list hsep
dutch_combined_list com xs = 
    let helper op [] = [ text "]" ]
	helper op (x : xs) = ( op <+> x ) : helper comma xs
    in  com $ helper ( text "[" ) xs


-- local variables:
-- mode: haskell
-- end:
