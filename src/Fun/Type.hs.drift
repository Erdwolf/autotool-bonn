-- -*- mode: haskell -*-

module Fun.Type 

( Fun (..), Exp (..), Mark (..)
, RAM.Builtin.Builtin (..)
)

where

-- -- $Id$

import ToDoc
import Reader
import Size

import qualified RAM.Builtin

data Fun = 
	 -- Grundfunktionen
	   Zero Int
	 | Succ Int
	 | Decr Int -- naja
	 | Proj Int Int

	 -- so tun, also ob Grundfunktion
	 | Builtin Int RAM.Builtin.Builtin

	 -- Operatoren
	 | Sub Int [ Fun ]
	 | PR  Int [ Fun ]
	 | Min Int [ Fun ]


    deriving (Eq, Ord)

instance Size Fun where
    size ( Sub i fs ) = succ $ sum $ map size fs 
    size ( PR  i fs ) = succ $ sum $ map size fs 
    size ( Min i fs ) = succ $ sum $ map size fs 
    size _ = 1

data Exp
        = Zahl Integer
	-- non-strikt
        | App Fun [ Exp ]
	-- nur auf dem Stack benutzt, für Builtins (die sind strikt)
	-- wende builtin auf die obersten stack-elemente an
	| Builtin_ Int RAM.Builtin.Builtin
	-- benutzt für PRs, deren letztes arg schon auf stack steht
	| App_ Fun [ Exp ]
	-- top of stack in cache eintragen
	| M Mark
    deriving ( Eq, Ord )


-- wollen wir nicht ausgeben
data Mark = Mark Exp deriving (Eq, Ord)

instance ToDoc  Mark where toDoc m = text "{..}"
instance Reader Mark -- ohne implementierung

{-! for Fun derive : ToDoc, Reader !-}

instance Show Fun where
    show = render . toDoc

instance Read Fun where
    readsPrec = parsec_readsPrec

{-! for Exp derive : ToDoc, Reader !-}

instance Show Exp where
    show = render . toDoc

instance Read Exp where
    readsPrec = parsec_readsPrec





