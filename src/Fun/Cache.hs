{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "Fun/Cache.hs.drift" #-}
-- -*- mode: haskell -*-

module Fun.Cache 

-- $Id$

( Cache -- abstrakt
, empty
, lookup
, insert
)

where

import FiniteMap
import ReadFM

import ToDoc
import Reader

data Ord k => Cache k e = Cache ( FiniteMap k e )

{-! for Cache derive : Reader, ToDoc !-}

instance (Ord k, ToDoc k, ToDoc e) => Show (Cache k e) where
    show = render . toDoc

instance (Ord k, Reader k, Reader e) => Read (Cache k e) where
    readsPrec = parsec_readsPrec


empty :: Ord k => Cache k e
empty = Cache emptyFM

lookup :: Ord k => Cache k e -> k -> Maybe e
lookup (Cache c) k = lookupFM c k

insert :: Ord k => Cache k e -> k -> e -> Cache k e
insert (Cache c) k e = Cache (addToFM c k e)

{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance (Ord k,Reader k,Reader e) => Reader (Cache k e) where
    readerPrec d =
	       readerParen (d > 9)
	       (do my_reserved "Cache"
		   aa <- readerPrec 0
		   return (Cache aa))

instance (Ord k,ToDoc k,ToDoc e) => ToDoc (Cache k e) where
    toDocPrec d (Cache aa) = docParen (d >= 10)
	      (text "Cache" <+> fsep [toDocPrec 10 aa])

--  Imported from other files :-
