-- -*- mode: haskell -*-

module Control.Types 

( HiLo (..)
, Wert (..)
, MNr, SNr, ANr, GNr, VNr -- abstrakt
, ClockTime
, Typ, Config, Remark, Name, Email
, Oks, Nos
, Time
, FromCGI (..)
, ToString (..)
)

where

--  $Id$

import Autolib.Reader
import Autolib.ToDoc

import System.Time
import Control.SQL
import Inter.Crypt
import Data.Char ( toLower )
import Database.MySQL.HSQL

import qualified Exception
import Data.Typeable
import Text.XML.HaXml.Haskell2Xml hiding ( Name )

-------------------------------------------------------------

class FromCGI a where fromCGI :: String -> a
class ToString a where toString :: a -> String

-------------------------------------------------------------

instance ToEx Crypt where 
    toEx c = EString ( unCrypt c )
instance SqlBind Crypt where 
    fromSqlValue _ s = Just $ Crypt s
    toSqlValue c = unCrypt c

--------------------------------------------------------------

data Time = Time String deriving ( Eq, Ord, Typeable )

{-! for Time derive : Reader, ToDoc, Haskell2Xml !-}

instance Show Time where show = render . toDoc
instance Read Time where readsPrec = parsec_readsPrec
instance SqlBind Time where 
    fromSqlValue _ s = Just $ Time s
    toSqlValue (Time s) = s

instance ToEx Time where
    toEx (Time x) = EString x
instance FromCGI Time where
    fromCGI s = Time s
instance ToString Time where
    toString (Time x) = x

-------------------------------------------------------------

data HiLo = Keine | High | Low 
    deriving ( Eq, Ord, Typeable, Bounded, Enum )

{-! for HiLo derive : Reader, ToDoc, Haskell2Xml !-}

instance Show HiLo where show = render . toDoc
instance Read HiLo where readsPrec = parsec_readsPrec
instance SqlBind HiLo where 
    fromSqlValue _ s = Just $ case parse (parse_complete reader) "string" s of
        Right x -> x
	Left e -> Keine
    toSqlValue w = show w

instance ToEx HiLo where
    toEx x = EString $ show x

data Wert = No | Ok Int deriving ( Eq, Ord, Typeable )

{-! for Wert derive : Reader, ToDoc, Haskell2Xml !-}

instance Show Wert where show = render . toDoc
instance Read Wert where readsPrec = parsec_readsPrec
instance SqlBind Wert where
    fromSqlValue _ _ = error "undefined"
    toSqlValue _ = error "undefined"

-------------------------------------------------------------

-- | Matrikel-Nummer
-- FIXME: sollte das lieber ein String sein? School fehlt auch noch.
data MNr = MNr Integer deriving ( Eq, Ord, Typeable )

{-! for MNr derive: ToDoc, Reader, Haskell2Xml !-}

instance Show MNr where show = render . toDoc
instance Read MNr where readsPrec = parsec_readsPrec
instance SqlBind MNr where 
    -- fromSqlValue ty s = fmap MNr $ fromSqlValue ty s
    fromSqlValue _ s = Just $ MNr $ read s
    toSqlValue (MNr i) = toSqlValue i

instance FromCGI MNr where
    fromCGI cs = MNr $ case readsPrec 0 cs of
              [(i, rest)] -> i
	      sonst -> error $ "FromCGI MNr:" ++ show sonst -- FIXME: error checking
instance ToString MNr where
    toString (MNr i) = show i

instance ToEx MNr where
    toEx (MNr i) = EInteger i

-------------------------------------------------------------------

-- | Aufgaben-Typ
data Typ = Typ String deriving ( Eq, Ord, Typeable )

{-! for Typ derive: ToDoc, Reader, Haskell2Xml !-}

instance SqlBind Typ where 
    fromSqlValue ty s = Just $ Typ s
    toSqlValue (Typ cs) = toSqlValue cs
instance ToEx Typ where
    toEx (Typ x) = EString x
instance FromCGI Typ where
    fromCGI cs = Typ cs
instance ToString Typ where 
    toString (Typ cs) = cs

------------------------------------------------------------

-- | Aufgaben-Email
data Email = Email String deriving ( Eq, Ord, Typeable )

{-! for Email derive: ToDoc, Reader, Haskell2Xml !-}

instance SqlBind Email where 
    fromSqlValue ty s = Just $ Email s
    toSqlValue (Email cs) = toSqlValue cs
instance ToEx Email where
    toEx (Email x) = EString x
instance FromCGI Email where
    fromCGI cs = Email cs
instance ToString Email where 
    toString (Email cs) = cs

------------------------------------------------------------

-- | Aufgaben-Config
data Config = Config String deriving ( Eq, Ord, Typeable )
{-! for Config derive: Reader, ToDoc, Haskell2Xml !-}


instance SqlBind Config where 
    fromSqlValue ty s = Just $ Config s
    toSqlValue (Config cs) = toSqlValue cs
instance ToEx Config where
    toEx (Config x) = EString x
instance ToString Config where
    toString ( Config s ) = s
instance FromCGI Config where
    fromCGI s = Config s

-- | Aufgaben-Remark
data Remark = Remark String deriving ( Eq, Ord, Typeable )

{-! for Remark derive: ToDoc, Reader, Haskell2Xml !-}

instance SqlBind Remark where 
    fromSqlValue ty s = Just $ Remark s
    toSqlValue (Remark cs) = toSqlValue cs
instance ToEx Remark where
    toEx (Remark x) = EString x
instance ToString Remark where
    toString ( Remark s ) = s
instance FromCGI Remark where
    fromCGI s = Remark s

-- | Aufgaben-Name
data Name = Name String deriving ( Eq, Ord, Typeable )

{-! for Name derive: ToDoc, Reader, Haskell2Xml !-}

instance SqlBind Name where 
    fromSqlValue ty s = Just $ Name s
    toSqlValue (Name cs) = toSqlValue cs
instance ToEx Name where
    toEx (Name x) = EString x
instance ToString Name where 
    toString (Name cs) = cs
instance FromCGI Name where
    fromCGI cs = Name cs

-------------------------------------------------------------

-- | Studenten-Nummer
data SNr = SNr Int deriving ( Eq, Ord, Typeable )

{-! for SNr derive: ToDoc, Reader, Haskell2Xml !-}

instance SqlBind SNr where 
    fromSqlValue _ s = Just $ SNr $ read s -- FIXME: check SqlType
    toSqlValue (SNr i) = toSqlValue i

instance ToEx SNr where
    toEx (SNr x) = EString $ show x
instance ToString SNr where
    toString (SNr x) = show x

-- | Aufgaben-Nummer

data ANr = ANr Int deriving ( Eq, Ord, Typeable )

{-! for ANr derive: ToDoc, Reader, Haskell2Xml !-}

instance SqlBind ANr where 
    fromSqlValue _ s = Just $ ANr $ read s -- FIXME: check SqlType
    toSqlValue (ANr i) = toSqlValue i
instance ToEx ANr where
    toEx (ANr x) = EString $ show x

-- | Gruppen-Nummer

data GNr = GNr Int deriving ( Eq, Ord, Typeable )

{-! for GNr derive: ToDoc, Reader, Haskell2Xml !-}

instance SqlBind GNr where 
    fromSqlValue _ s = Just $ GNr $ read s -- FIXME: check SqlType
    toSqlValue (GNr i) = toSqlValue i
instance ToEx GNr where
    toEx (GNr x) = EString $ show x
instance FromCGI GNr where
    fromCGI cs = GNr $ read cs

-- | Vorlesungs-Nummer

data VNr = VNr Int deriving ( Eq, Ord, Typeable )

{-! for VNr derive: ToDoc, Reader, Haskell2Xml !-}

instance SqlBind VNr where 
    fromSqlValue _ s = Just $ VNr $ read s -- FIXME: check SqlType
    toSqlValue (VNr i) = toSqlValue i
instance ToEx VNr where
    toEx (VNr x) = EString $ show x

-- | OK-Bewertung (Anzahl)

data Oks = Oks Int deriving ( Eq, Ord, Typeable )

{-! for Oks derive: ToDoc, Reader, Haskell2Xml !-}

instance SqlBind Oks where 
    fromSqlValue ty s = fmap Oks $ fromSqlValue ty s
    toSqlValue (Oks i) = toSqlValue i

-- | No-Bewertung (Anzahl)

data Nos = Nos Int deriving ( Eq, Ord, Typeable )

{-! for Nos derive: ToDoc, Reader, Haskell2Xml !-}

instance SqlBind Nos where 
    fromSqlValue ty s = fmap Nos $ fromSqlValue ty s
    toSqlValue (Nos i) = toSqlValue i

-------------------------------------------------------------

