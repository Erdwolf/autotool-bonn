-- -*- mode: haskell -*-

module SAT.Types where

--   $Id$

import Autolib.FiniteMap
import Autolib.Set
import Autolib.ToDoc
import Autolib.Reader

import Data.Typeable


-- | Bemerkungen: 
-- 1. Aussagenlogische Formel in konjunktiver Normalform (KNF):
-- Literal = Variable oder nonVariableVariable
-- Klausel= Literal || Literal ||...|| Literal 	
-- KNF = Klausel && Klausel && ... && Klausel

data SAT = SAT deriving ( Show, Typeable )

-- | Elementare Def.
data Literal = Pos Variable | Neg Variable
    deriving ( Eq, Ord, Typeable)

unLiteral ( Pos v ) = v
unLiteral ( Neg v ) = v

opposite ( Pos v ) = Neg v
opposite ( Neg v ) = Pos v

{-! for Literal derive : ToDoc, Reader !-}


-- | Klausel = Tripeln von Literalen

data Klausel = Or [ Literal ] deriving ( Eq, Ord , Typeable)

literale :: Klausel -> [ Literal ]
literale (Or lits) = lits

{-! for Klausel derive : ToDoc, Reader !-}


-- | Formeln in 3KNF = Liste von Klauseln
data Formel = And [Klausel] deriving ( Typeable )

klauseln :: Formel -> [ Klausel ]
klauseln (And cls) = cls

{-! for Formel derive : ToDoc, Reader !-}


type Variable = String 


type Belegung = FiniteMap Variable Bool

variablen :: Formel -> Set Variable
variablen (And cls) = mkSet $ do
    Or lits <- cls
    lit <- lits
    return $ case lit of Pos v -> v ; Neg v -> v

