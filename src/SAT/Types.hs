{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "challenger/SAT/Types.hs.drift" #-}
module SAT.Types where

-- $Id$

import FiniteMap
import ToDoc
import Reader
import ReadFM


-- *****************************************************************
--Bemerkungen: 
--1. Aussagenlogische Formel in konjunktiver Normalform (KNF):
--Literal = Variable oder nonVariableVariable
--Klausel= Literal || Literal ||...|| Literal 	
--KNF = Klausel && Klausel && ... && Klausel
-- *****************************************************************

data SAT = SAT deriving Show

-- Elementare Def.
data Literal = Pos Variable | Neg Variable
    deriving (Show,Read,Eq,Ord)

{-! for Literal derive : ToDoc, Reader !-}


--Klausel = Tripeln von Literalen
type Klausel = (Literal,Literal,Literal)

--Formeln in 3KNF = Liste von Klauseln
type Formel = [Klausel]

--Variable = String
type Variable = String 

--Belegung = Variable -> B00l
type Belegung = FiniteMap Variable Bool
type Map = [(Literal,Literal)]


{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance ToDoc Literal where
    toDocPrec d (Pos aa) = docParen (d >= 10)
	      (text "Pos" <+> fsep [toDocPrec 0 aa])
    toDocPrec d (Neg aa) = docParen (d >= 10)
	      (text "Neg" <+> fsep [toDocPrec 0 aa])

instance Reader Literal where
    readerPrec d =
	       readerParen (d > 9)
	       (do my_reserved "Pos"
		   aa <- readerPrec 0
		   return (Pos aa))
	       <|>
	       readerParen (d > 9)
	       (do my_reserved "Neg"
		   aa <- readerPrec 0
		   return (Neg aa))

--  Imported from other files :-
