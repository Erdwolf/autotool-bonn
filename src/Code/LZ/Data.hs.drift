{-# OPTIONS -fallow-overlapping-instances -fglasgow-exts #-}

module Code.LZ.Data where

import Autolib.Reader
import Autolib.ToDoc
import Autolib.Size
import Autolib.Set
import Autolib.FiniteMap

import Data.Typeable
import Text.XML.HaXml.Haskell2Xml

data Lempel_Ziv_Welch  = Lempel_Ziv_Welch  deriving ( Eq, Ord, Typeable )
data Lempel_Ziv_77 = Lempel_Ziv_77 deriving ( Eq, Ord, Typeable )

{-! for Lempel_Ziv_Welch derive: Reader, ToDoc, Haskell2Xml !-}
{-! for Lempel_Ziv_77 derive: Reader, ToDoc, Haskell2Xml !-}

data Code_Letter a = Letter a
                   | Entry Int -- ^ num in dict
                   | Block { width :: Int, dist :: Int } 
                      -- ^ relative position in stream
     deriving ( Eq, Ord, Typeable )

{-! for Code_Letter derive: Reader, ToDoc, Haskell2Xml !-}

instance Size (Code_Letter a) where
    size (Letter _) = 1
    size (Entry i) = bits i
    size (Block { dist = d, width = w })  = bits d + bits w

bits :: Int -> Int
bits x | x > 1 = 1 + bits (x `div` 2 )
bits _ = 1

data ( ToDoc [a], Ord a, Reader [a] ) 
    => Book a = Book
          { short  :: Set a 
          , long :: FiniteMap [a] Int
          }
    deriving ( Eq, Ord, Typeable )

{-! for Book derive: Reader, ToDoc, Haskell2Xml !-}

leer :: ( ToDoc [a], Reader [a], Ord a ) => Book a
leer = Book { short = emptySet , long = emptyFM }

data ( ToDoc [a], ToDoc [b], Ord a, Reader [a], Reader [b] ) 
    => Cache a b = Cache
          { book :: Book a
          , output  :: [ b ] 
          }

{-! for Cache derive: Reader, ToDoc, Haskell2Xml !-}

blank ::  ( ToDoc [a], ToDoc [b], Ord a, Reader [a], Reader [b] ) 
      => Cache a b
blank = Cache { book = leer , output = [] }


-- Local variables:
-- mode: haskell
-- End:
