{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "challenger/PCProblem/Konfig.hs.drift" #-}
-- -*- mode: haskell -*-

module PCProblem.Konfig where

import PCProblem.Type

import ToDoc
import Reader

data Konfig = 
     Konfig { instanz :: PCP
	    , folge :: Folge -- achtung, falschrum! (damit wir vorn dranbauen)
	    , tief :: Int
	    , oben :: String  -- einer von beiden soll leer sein
	    , unten :: String -- d. h. gemeinsame präfixe werden abgeschnitten
	    }

wesen :: Konfig -> ( Int, Int, String, String )
-- zum schnelleren vergleichen
wesen k = ( length $ oben k, length $ unten k
	  , oben k         , unten k 
	  )

instance Eq Konfig where 
    k1 == k2 = wesen k1 == wesen k2
instance Ord Konfig where 
    compare k1 k2 = compare ( wesen k1 ) ( wesen k2 )

{-! for Konfig derive: ToDoc, Reader !-}

instance Show Konfig where show = render . toDoc
instance Read Konfig where readsPrec = parsec_readsPrec
{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance ToDoc Konfig where
    toDocPrec d (Konfig aa ab ac ad ae) = docParen (d >= 10)
	      (text "Konfig" <+> dutch_record
	       [text "instanz" <+> equals <+> toDocPrec 0 aa,
		text "folge" <+> equals <+> toDocPrec 0 ab,
		text "tief" <+> equals <+> toDocPrec 0 ac,
		text "oben" <+> equals <+> toDocPrec 0 ad,
		text "unten" <+> equals <+> toDocPrec 0 ae])

instance Reader Konfig where
    readerPrec d =
	       readerParen (d > 9)
	       (do my_reserved "Konfig"
		   my_braces ((do my_reserved "instanz"
				  my_equals
				  aa <- readerPrec 0
				  my_comma
				  my_reserved "folge"
				  my_equals
				  ab <- readerPrec 0
				  my_comma
				  my_reserved "tief"
				  my_equals
				  ac <- readerPrec 0
				  my_comma
				  my_reserved "oben"
				  my_equals
				  ad <- readerPrec 0
				  my_comma
				  my_reserved "unten"
				  my_equals
				  ae <- readerPrec 0
				  return (Konfig aa ab ac ad ae))))

--  Imported from other files :-
