{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "challenger/PCProblem/Param.hs.drift" #-}
-- -*- mode: haskell -*-

module PCProblem.Param where

import ToDoc
import Reader

data Param =
     Param { alpha :: String -- zu benutzende Buchstaben
	       , paare :: Int -- anzahl
	       , breite :: Int -- maximale wortlänge
	       , nah :: Int -- keines mit kürzerer lösung
	       , fern :: Int -- keines mit längerer lösung
	       , viel :: Int -- nur soviele Knoten im suchbaum (bfs)
	       }

g :: Param
g = Param { alpha = "abc"
	      , paare = 4
	      , breite = 3
	      , nah = 7
	      , fern = 20
	      , viel = 1000
	      }

{-! for Param derive: ToDoc, Reader !-}

instance Show Param where show = render . toDoc
instance Read Param where readsPrec = parsec_readsPrec
{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance ToDoc Param where
    toDocPrec d (Param aa ab ac ad ae af) = docParen (d >= 10)
	      (text "Param" <+> dutch_record
	       [text "alpha" <+> equals <+> toDocPrec 0 aa,
		text "paare" <+> equals <+> toDocPrec 0 ab,
		text "breite" <+> equals <+> toDocPrec 0 ac,
		text "nah" <+> equals <+> toDocPrec 0 ad,
		text "fern" <+> equals <+> toDocPrec 0 ae,
		text "viel" <+> equals <+> toDocPrec 0 af])

instance Reader Param where
    readerPrec d =
	       readerParen (d > 9)
	       (do my_reserved "Param"
		   my_braces ((do my_reserved "alpha"
				  my_equals
				  aa <- readerPrec 0
				  my_comma
				  my_reserved "paare"
				  my_equals
				  ab <- readerPrec 0
				  my_comma
				  my_reserved "breite"
				  my_equals
				  ac <- readerPrec 0
				  my_comma
				  my_reserved "nah"
				  my_equals
				  ad <- readerPrec 0
				  my_comma
				  my_reserved "fern"
				  my_equals
				  ae <- readerPrec 0
				  my_comma
				  my_reserved "viel"
				  my_equals
				  af <- readerPrec 0
				  return (Param aa ab ac ad ae af))))

--  Imported from other files :-
