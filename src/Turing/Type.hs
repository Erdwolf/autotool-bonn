{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "Turing/Type.hs.drift" #-}
module Turing.Type 

( module Turing.Type
, module Sets
, module FiniteMap
)

where

-- $Id$

import Sets
import FiniteMap
import ReadFM
import ToDoc
import Reader

data Bewegung = L | O | R
     deriving (Eq, Show, Ord)

{-! for Bewegung derive : ToDoc, Reader !-}

data Turing y z = 
     Turing { eingabealphabet  :: Set y
	    , arbeitsalphabet  :: Set y
	    , leerzeichen	     :: y
	    , zustandsmenge    :: Set z 
	    , tafel	     :: FiniteMap (y, z) (Set (y, z, Bewegung))
	    , startzustand     :: z
	    , endzustandsmenge :: Set z
	    }

{-! for Turing derive : ToDoc, Reader !-}


class (Ord y, Ord z, Show y, Show z, ToDoc y, ToDoc z
	 , ToDoc [y], ToDoc [z]) => TUM y z 
    -- ohne methoden, soll nur die constraints aufsammeln
instance TUM Char Integer


instance TUM y z => Show (Turing y z) where
    show = render . toDoc


lookupset :: Ord a => FiniteMap a (Set b) -> a -> Set b
lookupset fm x = case lookupFM fm x of
    Just m -> m; Nothing -> emptySet
{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance (ToDoc y,ToDoc z) => ToDoc (Turing y z) where
    toDocPrec d (Turing aa ab ac ad ae af ag) = docParen (d >= 10)
	      (text "Turing" <+> braces
	       (fsep (punctuate comma [text "eingabealphabet" <+> equals <+>
				       toDocPrec 10 aa,
				       text "arbeitsalphabet" <+> equals <+> toDocPrec 10 ab,
				       text "leerzeichen" <+> equals <+> toDocPrec 10 ac,
				       text "zustandsmenge" <+> equals <+> toDocPrec 10 ad,
				       text "tafel" <+> equals <+> toDocPrec 10 ae,
				       text "startzustand" <+> equals <+> toDocPrec 10 af,
				       text "endzustandsmenge" <+> equals <+> toDocPrec 10 ag])))

instance (Reader y,Reader z) => Reader (Turing y z) where
    readerPrec d =
	       readerParen (d > 9)
	       (do my_reserved "Turing"
		   my_braces (do my_reserved "eingabealphabet"
				 my_equals
				 aa <- readerPrec 0
				 my_comma
				 my_reserved "arbeitsalphabet"
				 my_equals
				 ab <- readerPrec 0
				 my_comma
				 my_reserved "leerzeichen"
				 my_equals
				 ac <- readerPrec 0
				 my_comma
				 my_reserved "zustandsmenge"
				 my_equals
				 ad <- readerPrec 0
				 my_comma
				 my_reserved "tafel"
				 my_equals
				 ae <- readerPrec 0
				 my_comma
				 my_reserved "startzustand"
				 my_equals
				 af <- readerPrec 0
				 my_comma
				 my_reserved "endzustandsmenge"
				 my_equals
				 ag <- readerPrec 0
				 return (Turing aa ab ac ad ae af ag)))

instance ToDoc Bewegung where
    toDocPrec d (L) = text "L"
    toDocPrec d (O) = text "O"
    toDocPrec d (R) = text "R"

instance Reader Bewegung where
    readerPrec d =
	       (do my_reserved "L"
		   return (L))
	       <|>
	       (do my_reserved "O"
		   return (O))
	       <|>
	       (do my_reserved "R"
		   return (R))

--  Imported from other files :-
