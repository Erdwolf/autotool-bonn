-- -*- mode: haskell -*-

module Turing.Type 

( module Turing.Type
, module Sets
, module Data.FiniteMap
)

where

--   $Id$

import Sets
import Size
import Data.FiniteMap
import ReadFM
import ToDoc
import Reader

import Data.Typeable
import TypeableFM

data Bewegung = L | O | R
     deriving (Eq, Ord, Show, Read, Typeable)

{-! for Bewegung derive : ToDoc, Reader !-}

data TM = TM -- for challenger instances
     deriving (Eq, Ord, Show, Read)
     
{-! for TM derive : ToDoc, Reader !-}

-- ohne methoden, soll nur die constraints aufsammeln
class ( Ord y
      , Show y, Show [y]
      , ToDoc y, ToDoc [y]
      , Reader y, Reader [y]  
      , Typeable y
      ) 
    => UM y
instance ( Ord y, Show y
	 , ToDoc y, ToDoc [y]
	 , Reader y, Reader [y]  
	 , Typeable y
	 )
    => UM y

class ( UM y, UM z ) => TUM y z 
instance ( UM y, UM z ) => TUM y z 


data (UM y, UM z) => Turing y z = 
     Turing { eingabealphabet  :: Set y
	    , arbeitsalphabet  :: Set y
	    , leerzeichen      :: y
	    , zustandsmenge    :: Set z 
	    , tafel	       :: FiniteMap (y, z) (Set (y, z, Bewegung))
	    , startzustand     :: z
	    , endzustandsmenge :: Set z
	    }
     deriving ( Typeable )

{-! for Turing derive : ToDoc, Reader !-}

instance TUM y z => Size (Turing y z) where size = size . zustandsmenge

unCollect :: TUM y z
	=> FiniteMap (y, z) (Set (y, z, Bewegung))
	-> [ ((y, z), (y, z, Bewegung)) ]
unCollect tf = do
    (arg, cont) <- fmToList tf
    val <- setToList cont
    return ( arg, val )

collect :: TUM y z
	=>  [ ((y, z), (y, z, Bewegung)) ]
	->  FiniteMap (y, z) (Set (y, z, Bewegung))
collect avs = addListToFM_C union emptyFM $ do
    ( a, v ) <- avs
    return ( a, unitSet v )


instance TUM y z => Show (Turing y z) where
    show = render . toDoc

instance ( TUM y z )
    => Read (Turing y z) where
    readsPrec = parsec_readsPrec

