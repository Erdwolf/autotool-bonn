-- -*- mode: haskell -*-

module Turing.Type 

( module Turing.Type
, module Autolib.Set
, module Autolib.FiniteMap
)

where

--   $Id$

import Autolib.Set
import Autolib.Size
import Autolib.FiniteMap

import Autolib.ToDoc
import Autolib.Reader

import Data.Typeable
import Autolib.Xml
import Text.XML.HaXml.Haskell2Xml


data Bewegung = L | O | R
     deriving (Eq, Ord, Typeable)

{-! for Bewegung derive : ToDoc, Reader, Haskell2Xml !-}

data TM = TM -- for challenger instances
     deriving (Eq, Ord, Typeable)
     
{-! for TM derive : ToDoc, Reader, Haskell2Xml !-}

-- ohne methoden, soll nur die constraints aufsammeln
class ( Ord y
      , Show y, Show [y]
      , ToDoc y, ToDoc [y]
      , Reader y, Reader [y]  
      , Typeable y , Haskell2Xml y
      ) 
    => UM y
instance ( Ord y, Show y
	 , ToDoc y, ToDoc [y]
	 , Reader y, Reader [y]  
	 , Typeable y, Haskell2Xml y
	 )
    => UM y

class ( UM y, UM z ) => TuringC y z 
instance ( UM y, UM z ) => TuringC y z 


data TuringC y z => Turing y z = 
     Turing { eingabealphabet  :: Set y
	    , arbeitsalphabet  :: Set y
	    , leerzeichen      :: y
	    , zustandsmenge    :: Set z 
	    , tafel	       :: FiniteMap (y, z) (Set (y, z, Bewegung))
	    , startzustand     :: z
	    , endzustandsmenge :: Set z
	    }
     deriving ( Typeable )

{-! for Turing derive : ToDoc, Reader, Haskell2Xml !-}

instance TuringC y z => Size (Turing y z) where size = size . zustandsmenge

instance Container (x, y, z) (x, (y, z)) where
    label _ = "Triple"
    pack (x,y,z) = (x,(y,z))
    unpack (x,(y,z)) = (x,y,z)