{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "DB/Data.hs.drift" #-}
-- -*- mode: haskell -*-

module DB.Data where

-- das wird serverseitig benutzt
-- der server weiß nichts über den inhalt der XML-dokumente

import FiniteMap

import Text.XML.HaXml.Types
import Text.XML.HaXml.Haskell2Xml

data Contents  = Contents { unContents :: [ Content ] }

-- das können wir nicht deriven
instance Haskell2Xml Contents where
    toHType _ = Prim "Xml" "xml"
    toContents ( Contents es ) 
	= [CElem (Elem "xml" [] es )]
    fromContents ( CElem (Elem "xml" [] es ) : cs ) 
	= ( Contents es , cs )
    fromContents ( _ : cs ) = fromContents cs

data Entry = Entry { ident :: String
		   , password :: String
		   , contents :: Maybe Contents
		   }

{-! for Entry derive : Haskell2Xml !-}

type Map = FiniteMap String Entry

{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance Haskell2Xml Entry where
    toHType v =
	Defined "Entry" []
		[Constr "Entry" [] [toHType aa,toHType ab,toHType ac]]
      where
	(Entry aa ab ac) = v
    fromContents (CElem (Elem constr [] cs):etc)
	| "Entry" `isPrefixOf` constr =
	    (\(aa,cs00)-> (\(ab,cs01)-> (\(ac,_)-> (Entry aa ab ac, etc))
					(fromContents cs01))
			  (fromContents cs00))
	    (fromContents cs)
    toContents v@(Entry aa ab ac) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab,toContents ac])]

--  Imported from other files :-
